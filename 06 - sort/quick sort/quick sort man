퀵소트 알고리즘

1. 시작(start)과 끝(end) 그리고 중간 피벗(x)이라는 요소를 지정
2. 피벗을 기준으로 작은수는 왼쪽, 큰수는 오른쪽으로 스왑하는것이 목적
3. start는 왼쪽에서 오른쪽으로 이동
4. end는 오른쪽에서 왼쪽으로 이동
5. 하나씩 이동하면 스왑을 진행
5. 만약 start > end가 되는 지점이라면 (1차 스왑핑이 완료)
6. 재귀호출(왼쪽)
7. 재귀호출(오른쪽)
8. 이런식으로 나머지 절반을 똑같은 방식으로 정렬하면서 마무리


큰 배열을 계속절반으로 나눠 소팅..소팅..소팅 하면서
완료해 나가는 전형적인 dvide and conquer (분할정복) 알고리즘


bubble sort, selection sort, insert sort는
최악의 경우 O(n2)인 상황이 있으나
퀵소트는 최악의 경우에도 O(nlogn)의 복잡도를 가진다
하지만
작고 간단한 규모의 정렬이라면 삽입정렬과 시간상으로 큰 차이는 없다.

c언어 표준라이브러리에서는 stdlib.h에 qsort()로 구현되어있다
qsort(배열,사이즈,1당사이즈,비교함수)

ex) qsort(x,30,sizeof(int), int_comp);
int_comp(a,b) a>b return -1; // 오름차순(작은수부터 큰수로 정렬)
                a>b return 1; //내림차순 (큰수부더 작은수 정렬)